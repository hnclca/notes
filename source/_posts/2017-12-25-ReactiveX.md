---
title: ReactiveX
comments: false
toc: true
date: 2017-12-25 14:19:08
tags:
	- patterns
---

使用观察流进行异步编程的API，组合了观察者模式、迭代器模式和函数编程思想。
**创建**
易于创建事件流和数据流。
**组合**
用类查询操作符组成和转换流。
**监听**
订阅观察流，执行响应。

<!-- more -->
### Observable
观察者订阅被观察者。观察者可以对被观察者发送的任意Item或Item序列进行响应。这利于并发操作，因为无需阻塞线程以等待被观察者发送对象，而是创建一个哨兵，可以在被观察者进行指定操作时进行响应。

![observable](/assets/images/2017/12/observable.png)

#### 创建
##### 异步工作流
*	观察者 -- 定义使用异步调用返回的值做某些事的方法。
*	被观察者 -- 异步调用。
*	订阅 -- 绑定观察者到被观察者，通常引发被观察者行为。
*	继续执行 -- 当异步调用返回，观察者的方法开始处理返回的数据。

##### onNext, onCompleted和onError
根据被观察者协议，它会调用0次或多次onNext，之后跟随onCompleted或onError。文档约定中，将onNext通常称为Items的发送，onCompleted或onError称为通知。
*	onNext
被观察者发送数据时调用，使用数据作为参数。
*	onCompleted
被观察者生成期望数据失败或遇到错误时调用，之后不会调用onNext和onCompleted。使用显示错误信息的数据作为参数。
*	onError
被观察者在没有遇到任何错误，最后一次调用onNext后调用。

##### 取消订阅
在一些ReactiveX实现中，有一个特殊的观察者接口，Subscriber，实现了unsubscribe方法。调用该方法表示Subscriber不再对当前订阅的被观察者有兴趣，如果当前被观察者没有任何观察者，可以选择停止产生和发送数据。
取消订阅的行为会传播到被观察者的整个操作链，使得各个环节停止发送数据。但这不能保证立刻停止，在没有观察者观察发送数据后，被观察者可能还会生成并尝试发送数据一会。

##### 命名约定的一些注意事项
每个特定语言的实现都有自身命名规范，所以没有规范的命名标准，尽管实现之间存在一些共性。
此外，一些名称在其他上下文中有不同的含义，或者在特定实现语言的买语中有些尴尬。
比如这里的onEvent命名模式(onNext, onCompleted, onError)，一些上下文中这些名字指代注册的事件处理器的方法，在ReactiveX中，指代处理器本身。

#### 热与冷
何时发送数据序列，这取决于被观察者。
*	热 -- 创建时开始发送数据，观察者可能从序列中部开始观察；
*	冷 -- 直到有观察者订阅才开始发送数据，观察者可以获取到完整序列；
在一些ReactiveX实现中，存在一些连接性被观察者，只当Connect方法调用后，才开始发送数据，不管是否存在观察者。

### Operators
每个实现ReactiveX的特定语言都实现了一系列的操作符，尽管实现之间大多是重叠的，也有些操作符在某些语言中实现。同时每种实现都倾向于用类似于该语言中其他上下文熟悉的方法的命名操作符。

#### 操作符链
大多操作符都操作被观察者并返回一个被观察者，允许链式调用操作符。每个操作符都修改前一个操作符返回的被观察者。这与建造者模式不同，建造者模式同样允许链式调用，但它的调用的方法间是没有顺序关系的。
被观察者的操作符之间不是独立的，而是依次运行，每个操作符操作的被观察者都是由前一个操作符生成的。


#### 操作符分类
观察者与被观察者只是ReactiveX的开始，它们本身不过是观察者模式的小小的扩展，比单个调用更适合于处理一序列事件。
ReactiveX的真正强大之处在于，操作符可以让你转换、组合、操作和处理被观察者发送的数据序列。
响应式操作符让你按声明习惯组合异步序列，拥有所有回调的优点，而没有异步系统嵌套回调处理的缺点。

这里的一些运算符并不是Reactive核心的一部分，但在一个或多个特定语言或可选模块中实现。
##### Creating Observable
*	Create -- 调用观察者方法来从头创建被观察者。
*	Defer -- 直到有观察者订阅才创建被观察者，为每个观察者创建一个新的被观察者。
*	Empty/Never/Throw -- 创建确切或有限行为的被观察者。
*	From -- 转换一些对象或数据结构为被观察者。
*	Interval -- 创建按指定时间间隔发送整数序列的被观察者。
*	Just -- 转换一个对象或对象的集合为被观察者，发送这些对象或对象的集合。
*	Range -- 创建发送一个区间整数的被观察者。
*	Repeat -- 创建重复发送特定Item或Item序列的被观察者。
*	Start -- 创建发送方法返回值的被观察者。
*	Timer -- 创建指定延时后发送单个Item的被观察者。

##### Transforming Observable Items
*	Buffer -- 周期性的集合Items项再发送，崦不是一次发送一个。
*	Flatmap -- 转换被观察者发送的Item项为被观察者，然后将这些发送的数据整合为一个单独的被观察者。
*	GroupBy -- 切割被观察者为一系列被观察者，每个发送由key组织的一组数据。
*	Map -- 使用Function函数转换被观察者发出的数据。
*	Scan -- 使用Function函数转换被观察者发出的数据，顺序地发送每个连续值。
*	Window -- 周期性的细分被观察者发送的数据到每个观察窗口，而不是一次发送一个数据。

##### Filtering Observable
*	Debounce -- 仅在特定时间内未发送任何数据项时，让被观察者发送一个数据。
*	Distinct -- 消除被观察者发送的重复数据项。
*	ElementAt -- 仅发送指定的第n个数据。
*	Filter -- 仅发送符合条件的数据。
*	First --仅发送第一个数据，或第一个符合条件的数据。
*	IgnoreElements -- 不发送任何数据，仅发送通知。
*	Last -- 仅发送最后一个数据。
*	Sample -- 发送在周期性时间间隔内发送最多的数据。
*	Skip -- 跳过发送的前n个数据。
*	SkipLast -- 跳过发送的最后n个数据。
*	Take -- 只发送前n个数据。
*	TakeLast -- 只发送后n个数据。

##### Combining Observable
*	And/Then/When -- 用Pattern和Plan中间人组合的两个或两个以上的被观察者数据的集合。
*	CombineLatest -- 当数据由两个被观察者任一个发出时，返回指定Function应用后的结果。
*	Join -- 组合指定时间窗口两个被观察者发出数据。
*	Merge -- 合并多个被观察者发出的数据为一个。
*	StartWith -- 在源被观察者发送数据之前发送一个指定的数据序列。
*	Switch -- 转换一个发送多个被观察者的被观察者为一个发送被观察者们最新发送的数据的被观察者。
*	Zip -- 使用一个特定的函数将多个观察者发送的数据整合成一个数据并发送。

##### Error Hanlding Operators
*	Catch -- 从onError的通知中恢复并无错地继续执行序列。
*	Retry -- 当源被观察者发送onError通知时，尝试重新订阅期望无错完成。

##### Utilty Operators
*	Delay -- 按指定时间延迟发送数据。
*	Do -- 注册动作来处理被观察者的不同生命周期事件。
*	Materialize/Dematerialize -- 将发送数据与通知都视为发送数据，或与此相反。
*	ObserveOn -- 指定观察者观察被观察者的调度器。
*	Serialize -- 强制被观察者调用序列化调用并要求良好执行。
*	Subscribe -- 开启被观察者的发送和通知操作。
*	SubscribeOn -- 指定被观察者开启订阅时使用的调度器。
*	TimeInterval -- 转换发出的数据为发出数据间的时间间隔。
*	Timeout -- 在指定时间内未收到任何数据时，发送一个onError通知。
*	Timestamp -- 添加一个时间戳到发送的数据中。
*	Using -- 创建与被观察者生命周期相同的一次性资源。

##### Conditional and Boolean Operators
*	All -- 判断是否所有发出的数据都满足条件。
*	Amb -- 仅发送多个被观察者中最先发送数据的被观察者的数据。
*	Contains -- 判断是否发送了特定的数据。
*	DefaultIfEmpty -- 如果未发送任何数据时，发送默认数据。
*	SequenceEqual -- 判断是否两个被观察者发送相同序列数据。
*	SkipUntil -- 丢弃第二个观察者发送数据前的所有数据。
*	SkipWhile -- 丢弃特定条件不满足前的数据。
*	TakeUntil -- 丢弃第二个观察者发送数据或终止后的数据。
*	TakeWhile -- 丢弃特定条件不满足后的数据。

##### Mathemtical and Aggregate Operators
*	Average -- 计算所有发送数据的平均值，仅发送该值。
*	Concat -- 合并两个或以上被观察者的数据，无需交错。
*	Count -- 计算所有发送数据的个数，仅发送该值。
*	Max -- 判断并仅发送最大值。
*	Min -- 判断并仅发送最小值。
*	Reduce -- 应用Function给发送的数据，仅发送最终结果。
*	Sum -- 计算所有发送数据的总和，仅发送该值。

##### Converting Observables
*	To -- 转换被观察者为别的对象或数据结构。

##### Connectable Observable Operators
*	Connect -- 指导连接性的被观察者开始发送数据。
*	Publish -- 转换普通的被观察者为连接性的被观察者。
*	RefCount -- 标记连接性的观察者行为为一个普通的被观察者。
*	Replay -- 保证所有的观察者都观察到了相同的数据序列，即使订阅时被观察者已经开始发送数据。

##### Backpressure Operators
一系列执行特定流控制策略的各种运算符。应对被观察者产生数据速度远大于观察者消耗速度的策略。

### Single
RxJava(它的派生比如RxGroovy & RxScala)开发了被观察者变量，Single。
Single类似于被观察者，但不同于被观察都发送一系列的数据-从0到无限，它一直发送一个值或一个onError通知。
因此，相对于被观察者订阅的三个方法，Single只需要两个: onSuccess和onError。

### Subject
Subject在一些ReactiveX实现中是一种桥梁或代理，它既是观察者也是被观察者，因为它订阅了一个或多个被观察者的同时，它再次发送它收到数据，或者发送新数据。
因为Subject订阅被观察者，它会触发被观察者开始发送数据，如果被观察者是冷性的，即在被订阅前不会发送数据，Subject可以使冷被观察者转换为热被观察者。
#### Subject类型
这里有四种为不同场景设计的Subject，不是所有的都有实现，一些实现使用了自身的命名约定，如RxScala中，PublishSubject在这里只是Subject。
##### AsyncSubject
仅发送最后一个数据，之后就结束了。如果没有发送任何数据，同样会以无任何数据而结束。
如果被观察者因异常终止，则不会发送任何数据，只是传达onError通知。

##### BehaviorSubject
以订阅时发送的最新的数据开始，如果没有发送任何数据，则发送默认数据。
如果订阅时被观察者因异常终止，则不会发送任何数据，只是传达onError通知。

##### PublishSubject
仅发送订阅之后产生的数据。因此Subject创建后与订阅之间的数据会丢失。
如果订阅时被观察者因异常终止，则不会发送任何数据，只是传达onError通知。

##### ReplaySubject
观察者会收到被观察者发送的所有数据，无论订阅时间如何。
这里有几个版本的ReplaySubject，在超出指定缓冲大小时或指定时间间隔过后抛弃旧数据。
使用ReplaySubject作为被观察者时，不要在多线程中调用onNext或其他on方法，因为会引发一致性问题，这违反观察者合约，在哪个数据或通知应该先重放上产生歧义。

### Scheduler
如果在多线程情况下使用，可指定操作符，特别是被观察者在指定的调度器上运行。
默认被观察者与观察者都在调用Subscribe方法的同一线程运行。SubscribeOn可指定被观察者运行的线程，ObserveOn可指定被观察者发送通知给观察者的线程。
SubscibeOn指定被观察者运行的线程，无关操作符链的哪个操作调用。ObserveOn影响被观察者接下来使用的操作符运行的线程。因此需要在操作符上调用多次ObserveOn保证操作符在指定的线程上运行。
![schedulers](/assets/images/2017/12/schedulers.png)